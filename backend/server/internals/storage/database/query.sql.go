// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package database

import (
	"context"
)

const getIndexedWords = `-- name: GetIndexedWords :many
SELECT DISTINCT word from word_data
`

func (q *Queries) GetIndexedWords(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, getIndexedWords)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var word string
		if err := rows.Scan(&word); err != nil {
			return nil, err
		}
		items = append(items, word)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSearchResultCount = `-- name: GetSearchResultCount :one
SELECT COUNT(DISTINCT u.url) as total_results
FROM urls u 
JOIN word_data wd ON u.url = wd.url
WHERE wd.word = ANY($1::text[])
`

func (q *Queries) GetSearchResultCount(ctx context.Context, dollar_1 []string) (int64, error) {
	row := q.db.QueryRow(ctx, getSearchResultCount, dollar_1)
	var total_results int64
	err := row.Scan(&total_results)
	return total_results, err
}

const getSearchResults = `-- name: GetSearchResults :many
SELECT u.url, u.title, u.description, u.content_summary, COUNT(DISTINCT wd.word) as word_match_count, ARRAY_AGG(wd.word) matched_words, SUM(wd.tf_idf)::DOUBLE PRECISION as total_relevance 
FROM urls u JOIN word_data wd
ON u.url = wd.url
WHERE wd.word = ANY($1::text[])
GROUP BY u.url ORDER BY word_match_count DESC, total_relevance DESC LIMIT $2 OFFSET $3
`

type GetSearchResultsParams struct {
	Column1 []string `json:"column_1"`
	Limit   int32    `json:"limit"`
	Offset  int32    `json:"offset"`
}

type GetSearchResultsRow struct {
	Url            string      `json:"url"`
	Title          string      `json:"title"`
	Description    string      `json:"description"`
	ContentSummary string      `json:"content_summary"`
	WordMatchCount int64       `json:"word_match_count"`
	MatchedWords   interface{} `json:"matched_words"`
	TotalRelevance float64     `json:"total_relevance"`
}

func (q *Queries) GetSearchResults(ctx context.Context, arg GetSearchResultsParams) ([]GetSearchResultsRow, error) {
	rows, err := q.db.Query(ctx, getSearchResults, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSearchResultsRow
	for rows.Next() {
		var i GetSearchResultsRow
		if err := rows.Scan(
			&i.Url,
			&i.Title,
			&i.Description,
			&i.ContentSummary,
			&i.WordMatchCount,
			&i.MatchedWords,
			&i.TotalRelevance,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWordDataByURL = `-- name: GetWordDataByURL :many
SELECT word, url, position_bits, term_frequency, idf, tf_idf
FROM word_data
WHERE url = $1
`

func (q *Queries) GetWordDataByURL(ctx context.Context, url string) ([]WordDatum, error) {
	rows, err := q.db.Query(ctx, getWordDataByURL, url)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WordDatum
	for rows.Next() {
		var i WordDatum
		if err := rows.Scan(
			&i.Word,
			&i.Url,
			&i.PositionBits,
			&i.TermFrequency,
			&i.Idf,
			&i.TfIdf,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWordDataByWord = `-- name: GetWordDataByWord :many
SELECT word, url, position_bits, term_frequency, idf, tf_idf
FROM word_data
WHERE word = $1
`

func (q *Queries) GetWordDataByWord(ctx context.Context, word string) ([]WordDatum, error) {
	rows, err := q.db.Query(ctx, getWordDataByWord, word)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WordDatum
	for rows.Next() {
		var i WordDatum
		if err := rows.Scan(
			&i.Word,
			&i.Url,
			&i.PositionBits,
			&i.TermFrequency,
			&i.Idf,
			&i.TfIdf,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWordDataByWordAndURL = `-- name: GetWordDataByWordAndURL :one
SELECT word, url, position_bits, term_frequency, idf, tf_idf
FROM word_data
WHERE word = $1 AND url = $2
`

type GetWordDataByWordAndURLParams struct {
	Word string `json:"word"`
	Url  string `json:"url"`
}

// Word Data Queries
func (q *Queries) GetWordDataByWordAndURL(ctx context.Context, arg GetWordDataByWordAndURLParams) (WordDatum, error) {
	row := q.db.QueryRow(ctx, getWordDataByWordAndURL, arg.Word, arg.Url)
	var i WordDatum
	err := row.Scan(
		&i.Word,
		&i.Url,
		&i.PositionBits,
		&i.TermFrequency,
		&i.Idf,
		&i.TfIdf,
	)
	return i, err
}
