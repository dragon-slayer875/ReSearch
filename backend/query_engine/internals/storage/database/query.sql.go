// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package database

import (
	"context"
)

const getDocumentWordCount = `-- name: GetDocumentWordCount :one
SELECT COUNT(*) FROM word_data WHERE url_id = $1
`

func (q *Queries) GetDocumentWordCount(ctx context.Context, urlID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getDocumentWordCount, urlID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getInvertedIndexByWords = `-- name: GetInvertedIndexByWords :many
SELECT word, document_bits, doc_frequency 
FROM inverted_index
WHERE word = ANY($1::text[])
`

func (q *Queries) GetInvertedIndexByWords(ctx context.Context, dollar_1 []string) ([]InvertedIndex, error) {
	rows, err := q.db.Query(ctx, getInvertedIndexByWords, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InvertedIndex
	for rows.Next() {
		var i InvertedIndex
		if err := rows.Scan(&i.Word, &i.DocumentBits, &i.DocFrequency); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSearchResults = `-- name: GetSearchResults :many
SELECT u.id, u.url, COUNT(DISTINCT wd.word) as word_match_count, ARRAY_AGG(wd.word) matched_words, SUM(wd.tf_idf)::DOUBLE PRECISION as total_relevance 
FROM urls u JOIN word_data wd
ON u.id = wd.url_id
WHERE wd.word = ANY($1::text[])
GROUP BY u.id
ORDER BY word_match_count DESC, total_relevance DESC
`

type GetSearchResultsRow struct {
	ID             int64       `json:"id"`
	Url            string      `json:"url"`
	WordMatchCount int64       `json:"word_match_count"`
	MatchedWords   interface{} `json:"matched_words"`
	TotalRelevance float64     `json:"total_relevance"`
}

func (q *Queries) GetSearchResults(ctx context.Context, dollar_1 []string) ([]GetSearchResultsRow, error) {
	rows, err := q.db.Query(ctx, getSearchResults, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSearchResultsRow
	for rows.Next() {
		var i GetSearchResultsRow
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.WordMatchCount,
			&i.MatchedWords,
			&i.TotalRelevance,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalIndexedDocumentCount = `-- name: GetTotalIndexedDocumentCount :one
SELECT COUNT(DISTINCT url_id) FROM word_data
`

// Additional utility queries
func (q *Queries) GetTotalIndexedDocumentCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalIndexedDocumentCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getWordCount = `-- name: GetWordCount :one
SELECT COUNT(*) FROM inverted_index
`

func (q *Queries) GetWordCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getWordCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getWordDataByURL = `-- name: GetWordDataByURL :many
SELECT word, url_id, position_bits, term_frequency, idf, tf_idf
FROM word_data
WHERE url_id = $1
`

func (q *Queries) GetWordDataByURL(ctx context.Context, urlID int64) ([]WordDatum, error) {
	rows, err := q.db.Query(ctx, getWordDataByURL, urlID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WordDatum
	for rows.Next() {
		var i WordDatum
		if err := rows.Scan(
			&i.Word,
			&i.UrlID,
			&i.PositionBits,
			&i.TermFrequency,
			&i.Idf,
			&i.TfIdf,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWordDataByWord = `-- name: GetWordDataByWord :many
SELECT word, url_id, position_bits, term_frequency, idf, tf_idf
FROM word_data
WHERE word = $1
`

func (q *Queries) GetWordDataByWord(ctx context.Context, word string) ([]WordDatum, error) {
	rows, err := q.db.Query(ctx, getWordDataByWord, word)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WordDatum
	for rows.Next() {
		var i WordDatum
		if err := rows.Scan(
			&i.Word,
			&i.UrlID,
			&i.PositionBits,
			&i.TermFrequency,
			&i.Idf,
			&i.TfIdf,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWordDataByWordAndURL = `-- name: GetWordDataByWordAndURL :one
SELECT word, url_id, position_bits, term_frequency, idf, tf_idf
FROM word_data
WHERE word = $1 AND url_id = $2
`

type GetWordDataByWordAndURLParams struct {
	Word  string `json:"word"`
	UrlID int64  `json:"url_id"`
}

// Word Data Queries
func (q *Queries) GetWordDataByWordAndURL(ctx context.Context, arg GetWordDataByWordAndURLParams) (WordDatum, error) {
	row := q.db.QueryRow(ctx, getWordDataByWordAndURL, arg.Word, arg.UrlID)
	var i WordDatum
	err := row.Scan(
		&i.Word,
		&i.UrlID,
		&i.PositionBits,
		&i.TermFrequency,
		&i.Idf,
		&i.TfIdf,
	)
	return i, err
}

const getWordFrequencySum = `-- name: GetWordFrequencySum :one
SELECT COALESCE(SUM(term_frequency), 0) FROM word_data WHERE url_id = $1
`

func (q *Queries) GetWordFrequencySum(ctx context.Context, urlID int64) (interface{}, error) {
	row := q.db.QueryRow(ctx, getWordFrequencySum, urlID)
	var coalesce interface{}
	err := row.Scan(&coalesce)
	return coalesce, err
}
