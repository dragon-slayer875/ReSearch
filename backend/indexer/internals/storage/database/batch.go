// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: batch.go

package database

import (
	"context"
	"errors"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgtype"
)

var (
	ErrBatchAlreadyClosed = errors.New("batch already closed")
)

const batchGetInvertedIndexByWord = `-- name: BatchGetInvertedIndexByWord :batchone
SELECT word, document_bits, doc_frequency
FROM inverted_index
WHERE word = $1
`

type BatchGetInvertedIndexByWordBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

func (q *Queries) BatchGetInvertedIndexByWord(ctx context.Context, word []string) *BatchGetInvertedIndexByWordBatchResults {
	batch := &pgx.Batch{}
	for _, a := range word {
		vals := []interface{}{
			a,
		}
		batch.Queue(batchGetInvertedIndexByWord, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &BatchGetInvertedIndexByWordBatchResults{br, len(word), false}
}

func (b *BatchGetInvertedIndexByWordBatchResults) QueryRow(f func(int, InvertedIndex, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		var i InvertedIndex
		if b.closed {
			if f != nil {
				f(t, i, ErrBatchAlreadyClosed)
			}
			continue
		}
		row := b.br.QueryRow()
		err := row.Scan(&i.Word, &i.DocumentBits, &i.DocFrequency)
		if f != nil {
			f(t, i, err)
		}
	}
}

func (b *BatchGetInvertedIndexByWordBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const batchInsertInvertedIndex = `-- name: BatchInsertInvertedIndex :batchone
INSERT INTO inverted_index (word, document_bits, doc_frequency)
VALUES ($1, $2, $3)
RETURNING word, document_bits, doc_frequency
`

type BatchInsertInvertedIndexBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type BatchInsertInvertedIndexParams struct {
	Word         string `json:"word"`
	DocumentBits []byte `json:"document_bits"`
	DocFrequency int64  `json:"doc_frequency"`
}

func (q *Queries) BatchInsertInvertedIndex(ctx context.Context, arg []BatchInsertInvertedIndexParams) *BatchInsertInvertedIndexBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.Word,
			a.DocumentBits,
			a.DocFrequency,
		}
		batch.Queue(batchInsertInvertedIndex, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &BatchInsertInvertedIndexBatchResults{br, len(arg), false}
}

func (b *BatchInsertInvertedIndexBatchResults) QueryRow(f func(int, InvertedIndex, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		var i InvertedIndex
		if b.closed {
			if f != nil {
				f(t, i, ErrBatchAlreadyClosed)
			}
			continue
		}
		row := b.br.QueryRow()
		err := row.Scan(&i.Word, &i.DocumentBits, &i.DocFrequency)
		if f != nil {
			f(t, i, err)
		}
	}
}

func (b *BatchInsertInvertedIndexBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const batchUpdateInvertedIndexByWord = `-- name: BatchUpdateInvertedIndexByWord :batchone
UPDATE inverted_index 
SET document_bits = $2,
    doc_frequency = $3
WHERE word = $1
RETURNING word, document_bits, doc_frequency
`

type BatchUpdateInvertedIndexByWordBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type BatchUpdateInvertedIndexByWordParams struct {
	Word         string `json:"word"`
	DocumentBits []byte `json:"document_bits"`
	DocFrequency int64  `json:"doc_frequency"`
}

func (q *Queries) BatchUpdateInvertedIndexByWord(ctx context.Context, arg []BatchUpdateInvertedIndexByWordParams) *BatchUpdateInvertedIndexByWordBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.Word,
			a.DocumentBits,
			a.DocFrequency,
		}
		batch.Queue(batchUpdateInvertedIndexByWord, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &BatchUpdateInvertedIndexByWordBatchResults{br, len(arg), false}
}

func (b *BatchUpdateInvertedIndexByWordBatchResults) QueryRow(f func(int, InvertedIndex, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		var i InvertedIndex
		if b.closed {
			if f != nil {
				f(t, i, ErrBatchAlreadyClosed)
			}
			continue
		}
		row := b.br.QueryRow()
		err := row.Scan(&i.Word, &i.DocumentBits, &i.DocFrequency)
		if f != nil {
			f(t, i, err)
		}
	}
}

func (b *BatchUpdateInvertedIndexByWordBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const updateWordIdf = `-- name: UpdateWordIdf :batchmany
UPDATE word_data 
SET idf = $2
WHERE word = $1
RETURNING word, url_id, term_frequency, idf
`

type UpdateWordIdfBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type UpdateWordIdfParams struct {
	Word string        `json:"word"`
	Idf  pgtype.Float8 `json:"idf"`
}

type UpdateWordIdfRow struct {
	Word          string        `json:"word"`
	UrlID         int64         `json:"url_id"`
	TermFrequency int32         `json:"term_frequency"`
	Idf           pgtype.Float8 `json:"idf"`
}

func (q *Queries) UpdateWordIdf(ctx context.Context, arg []UpdateWordIdfParams) *UpdateWordIdfBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.Word,
			a.Idf,
		}
		batch.Queue(updateWordIdf, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &UpdateWordIdfBatchResults{br, len(arg), false}
}

func (b *UpdateWordIdfBatchResults) Query(f func(int, []UpdateWordIdfRow, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		var items []UpdateWordIdfRow
		if b.closed {
			if f != nil {
				f(t, items, ErrBatchAlreadyClosed)
			}
			continue
		}
		err := func() error {
			rows, err := b.br.Query()
			if err != nil {
				return err
			}
			defer rows.Close()
			for rows.Next() {
				var i UpdateWordIdfRow
				if err := rows.Scan(
					&i.Word,
					&i.UrlID,
					&i.TermFrequency,
					&i.Idf,
				); err != nil {
					return err
				}
				items = append(items, i)
			}
			return rows.Err()
		}()
		if f != nil {
			f(t, items, err)
		}
	}
}

func (b *UpdateWordIdfBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const updateWordTfIdf = `-- name: UpdateWordTfIdf :batchone
UPDATE word_data
SET tf_idf = $3
WHERE word = $1 AND url_id = $2
RETURNING word, url_id, term_frequency, idf, tf_idf
`

type UpdateWordTfIdfBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type UpdateWordTfIdfParams struct {
	Word  string        `json:"word"`
	UrlID int64         `json:"url_id"`
	TfIdf pgtype.Float8 `json:"tf_idf"`
}

type UpdateWordTfIdfRow struct {
	Word          string        `json:"word"`
	UrlID         int64         `json:"url_id"`
	TermFrequency int32         `json:"term_frequency"`
	Idf           pgtype.Float8 `json:"idf"`
	TfIdf         pgtype.Float8 `json:"tf_idf"`
}

func (q *Queries) UpdateWordTfIdf(ctx context.Context, arg []UpdateWordTfIdfParams) *UpdateWordTfIdfBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.Word,
			a.UrlID,
			a.TfIdf,
		}
		batch.Queue(updateWordTfIdf, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &UpdateWordTfIdfBatchResults{br, len(arg), false}
}

func (b *UpdateWordTfIdfBatchResults) QueryRow(f func(int, UpdateWordTfIdfRow, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		var i UpdateWordTfIdfRow
		if b.closed {
			if f != nil {
				f(t, i, ErrBatchAlreadyClosed)
			}
			continue
		}
		row := b.br.QueryRow()
		err := row.Scan(
			&i.Word,
			&i.UrlID,
			&i.TermFrequency,
			&i.Idf,
			&i.TfIdf,
		)
		if f != nil {
			f(t, i, err)
		}
	}
}

func (b *UpdateWordTfIdfBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}
