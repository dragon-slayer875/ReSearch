// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

type BatchInsertWordDataParams struct {
	Word          string
	UrlID         int64
	PositionBits  []byte
	TermFrequency int32
}

const batchUpsertWordData = `-- name: BatchUpsertWordData :exec
INSERT INTO word_data (word, url_id, position_bits, term_frequency)
SELECT unnest($1::text[]), unnest($2::bigserial[]), unnest($3::bytea[]), unnest($4::int[])
ON CONFLICT (word, url_id) DO UPDATE SET
    position_bits = EXCLUDED.position_bits,
    term_frequency = EXCLUDED.term_frequency
`

type BatchUpsertWordDataParams struct {
	Column1 []string
	Column2 []int64
	Column3 [][]byte
	Column4 []int32
}

func (q *Queries) BatchUpsertWordData(ctx context.Context, arg BatchUpsertWordDataParams) error {
	_, err := q.db.Exec(ctx, batchUpsertWordData,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	return err
}

const getDocumentWordCount = `-- name: GetDocumentWordCount :one
SELECT COUNT(*) FROM word_data WHERE url_id = $1
`

func (q *Queries) GetDocumentWordCount(ctx context.Context, urlID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getDocumentWordCount, urlID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getInvertedIndexByWord = `-- name: GetInvertedIndexByWord :one
SELECT word, document_bits
FROM inverted_index
WHERE word = $1
`

func (q *Queries) GetInvertedIndexByWord(ctx context.Context, word string) (InvertedIndex, error) {
	row := q.db.QueryRow(ctx, getInvertedIndexByWord, word)
	var i InvertedIndex
	err := row.Scan(&i.Word, &i.DocumentBits)
	return i, err
}

const getInvertedIndexByWords = `-- name: GetInvertedIndexByWords :many
SELECT word, document_bits
FROM inverted_index
WHERE word = ANY($1::text[])
`

func (q *Queries) GetInvertedIndexByWords(ctx context.Context, dollar_1 []string) ([]InvertedIndex, error) {
	rows, err := q.db.Query(ctx, getInvertedIndexByWords, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InvertedIndex
	for rows.Next() {
		var i InvertedIndex
		if err := rows.Scan(&i.Word, &i.DocumentBits); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMetadataByURLID = `-- name: GetMetadataByURLID :one
SELECT url_id, title, meta_title, meta_description, meta_robots
FROM metadata
WHERE url_id = $1
`

func (q *Queries) GetMetadataByURLID(ctx context.Context, urlID int64) (Metadata, error) {
	row := q.db.QueryRow(ctx, getMetadataByURLID, urlID)
	var i Metadata
	err := row.Scan(
		&i.UrlID,
		&i.Title,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.MetaRobots,
	)
	return i, err
}

const getWordCount = `-- name: GetWordCount :one
SELECT COUNT(*) FROM inverted_index
`

// Additional utility queries
func (q *Queries) GetWordCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getWordCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getWordDataByURL = `-- name: GetWordDataByURL :many
SELECT word, url_id, position_bits, term_frequency
FROM word_data
WHERE url_id = $1
`

func (q *Queries) GetWordDataByURL(ctx context.Context, urlID int64) ([]WordDatum, error) {
	rows, err := q.db.Query(ctx, getWordDataByURL, urlID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WordDatum
	for rows.Next() {
		var i WordDatum
		if err := rows.Scan(
			&i.Word,
			&i.UrlID,
			&i.PositionBits,
			&i.TermFrequency,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWordDataByWord = `-- name: GetWordDataByWord :many
SELECT word, url_id, position_bits, term_frequency
FROM word_data
WHERE word = $1
`

func (q *Queries) GetWordDataByWord(ctx context.Context, word string) ([]WordDatum, error) {
	rows, err := q.db.Query(ctx, getWordDataByWord, word)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WordDatum
	for rows.Next() {
		var i WordDatum
		if err := rows.Scan(
			&i.Word,
			&i.UrlID,
			&i.PositionBits,
			&i.TermFrequency,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWordDataByWordAndURL = `-- name: GetWordDataByWordAndURL :one
SELECT word, url_id, position_bits, term_frequency
FROM word_data
WHERE word = $1 AND url_id = $2
`

type GetWordDataByWordAndURLParams struct {
	Word  string
	UrlID int64
}

func (q *Queries) GetWordDataByWordAndURL(ctx context.Context, arg GetWordDataByWordAndURLParams) (WordDatum, error) {
	row := q.db.QueryRow(ctx, getWordDataByWordAndURL, arg.Word, arg.UrlID)
	var i WordDatum
	err := row.Scan(
		&i.Word,
		&i.UrlID,
		&i.PositionBits,
		&i.TermFrequency,
	)
	return i, err
}

const getWordFrequencySum = `-- name: GetWordFrequencySum :one
SELECT COALESCE(SUM(term_frequency), 0) FROM word_data WHERE url_id = $1
`

func (q *Queries) GetWordFrequencySum(ctx context.Context, urlID int64) (interface{}, error) {
	row := q.db.QueryRow(ctx, getWordFrequencySum, urlID)
	var coalesce interface{}
	err := row.Scan(&coalesce)
	return coalesce, err
}

const insertInvertedIndex = `-- name: InsertInvertedIndex :one
INSERT INTO inverted_index (word, document_bits)
VALUES ($1, $2)
RETURNING word, document_bits
`

type InsertInvertedIndexParams struct {
	Word         string
	DocumentBits []byte
}

// Inverted Index Queries
func (q *Queries) InsertInvertedIndex(ctx context.Context, arg InsertInvertedIndexParams) (InvertedIndex, error) {
	row := q.db.QueryRow(ctx, insertInvertedIndex, arg.Word, arg.DocumentBits)
	var i InvertedIndex
	err := row.Scan(&i.Word, &i.DocumentBits)
	return i, err
}

const insertMetadata = `-- name: InsertMetadata :one
INSERT INTO metadata (url_id, title, meta_title, meta_description, meta_robots)
VALUES ($1, $2, $3, $4, $5)
RETURNING url_id, title, meta_title, meta_description, meta_robots
`

type InsertMetadataParams struct {
	UrlID           int64
	Title           pgtype.Text
	MetaTitle       pgtype.Text
	MetaDescription pgtype.Text
	MetaRobots      pgtype.Text
}

func (q *Queries) InsertMetadata(ctx context.Context, arg InsertMetadataParams) (Metadata, error) {
	row := q.db.QueryRow(ctx, insertMetadata,
		arg.UrlID,
		arg.Title,
		arg.MetaTitle,
		arg.MetaDescription,
		arg.MetaRobots,
	)
	var i Metadata
	err := row.Scan(
		&i.UrlID,
		&i.Title,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.MetaRobots,
	)
	return i, err
}

const insertWordData = `-- name: InsertWordData :one
INSERT INTO word_data (word, url_id, position_bits, term_frequency)
VALUES ($1, $2, $3, $4)
RETURNING word, url_id, position_bits, term_frequency
`

type InsertWordDataParams struct {
	Word          string
	UrlID         int64
	PositionBits  []byte
	TermFrequency int32
}

// Word Data Queries
func (q *Queries) InsertWordData(ctx context.Context, arg InsertWordDataParams) (WordDatum, error) {
	row := q.db.QueryRow(ctx, insertWordData,
		arg.Word,
		arg.UrlID,
		arg.PositionBits,
		arg.TermFrequency,
	)
	var i WordDatum
	err := row.Scan(
		&i.Word,
		&i.UrlID,
		&i.PositionBits,
		&i.TermFrequency,
	)
	return i, err
}

const updateInvertedIndex = `-- name: UpdateInvertedIndex :one
UPDATE inverted_index 
SET document_bits = $2
WHERE word = $1
RETURNING word, document_bits
`

type UpdateInvertedIndexParams struct {
	Word         string
	DocumentBits []byte
}

func (q *Queries) UpdateInvertedIndex(ctx context.Context, arg UpdateInvertedIndexParams) (InvertedIndex, error) {
	row := q.db.QueryRow(ctx, updateInvertedIndex, arg.Word, arg.DocumentBits)
	var i InvertedIndex
	err := row.Scan(&i.Word, &i.DocumentBits)
	return i, err
}

const updateMetadata = `-- name: UpdateMetadata :one
UPDATE metadata 
SET title = $2, meta_title = $3, meta_description = $4, meta_robots = $5
WHERE url_id = $1
RETURNING url_id, title, meta_title, meta_description, meta_robots
`

type UpdateMetadataParams struct {
	UrlID           int64
	Title           pgtype.Text
	MetaTitle       pgtype.Text
	MetaDescription pgtype.Text
	MetaRobots      pgtype.Text
}

func (q *Queries) UpdateMetadata(ctx context.Context, arg UpdateMetadataParams) (Metadata, error) {
	row := q.db.QueryRow(ctx, updateMetadata,
		arg.UrlID,
		arg.Title,
		arg.MetaTitle,
		arg.MetaDescription,
		arg.MetaRobots,
	)
	var i Metadata
	err := row.Scan(
		&i.UrlID,
		&i.Title,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.MetaRobots,
	)
	return i, err
}

const updateWordData = `-- name: UpdateWordData :one
UPDATE word_data 
SET position_bits = $3, term_frequency = $4
WHERE word = $1 AND url_id = $2
RETURNING word, url_id, position_bits, term_frequency
`

type UpdateWordDataParams struct {
	Word          string
	UrlID         int64
	PositionBits  []byte
	TermFrequency int32
}

func (q *Queries) UpdateWordData(ctx context.Context, arg UpdateWordDataParams) (WordDatum, error) {
	row := q.db.QueryRow(ctx, updateWordData,
		arg.Word,
		arg.UrlID,
		arg.PositionBits,
		arg.TermFrequency,
	)
	var i WordDatum
	err := row.Scan(
		&i.Word,
		&i.UrlID,
		&i.PositionBits,
		&i.TermFrequency,
	)
	return i, err
}

const upsertInvertedIndex = `-- name: UpsertInvertedIndex :one
INSERT INTO inverted_index (word, document_bits)
VALUES ($1, $2)
ON CONFLICT (word) DO UPDATE SET
    document_bits = EXCLUDED.document_bits
RETURNING word, document_bits
`

type UpsertInvertedIndexParams struct {
	Word         string
	DocumentBits []byte
}

func (q *Queries) UpsertInvertedIndex(ctx context.Context, arg UpsertInvertedIndexParams) (InvertedIndex, error) {
	row := q.db.QueryRow(ctx, upsertInvertedIndex, arg.Word, arg.DocumentBits)
	var i InvertedIndex
	err := row.Scan(&i.Word, &i.DocumentBits)
	return i, err
}

const upsertMetadata = `-- name: UpsertMetadata :one
INSERT INTO metadata (url_id, title, meta_title, meta_description, meta_robots)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (url_id) DO UPDATE SET
    title = EXCLUDED.title,
    meta_title = EXCLUDED.meta_title,
    meta_description = EXCLUDED.meta_description,
    meta_robots = EXCLUDED.meta_robots
RETURNING url_id, title, meta_title, meta_description, meta_robots
`

type UpsertMetadataParams struct {
	UrlID           int64
	Title           pgtype.Text
	MetaTitle       pgtype.Text
	MetaDescription pgtype.Text
	MetaRobots      pgtype.Text
}

func (q *Queries) UpsertMetadata(ctx context.Context, arg UpsertMetadataParams) (Metadata, error) {
	row := q.db.QueryRow(ctx, upsertMetadata,
		arg.UrlID,
		arg.Title,
		arg.MetaTitle,
		arg.MetaDescription,
		arg.MetaRobots,
	)
	var i Metadata
	err := row.Scan(
		&i.UrlID,
		&i.Title,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.MetaRobots,
	)
	return i, err
}

const upsertWordData = `-- name: UpsertWordData :one
INSERT INTO word_data (word, url_id, position_bits, term_frequency)
VALUES ($1, $2, $3, $4)
ON CONFLICT (word, url_id) DO UPDATE SET
    position_bits = EXCLUDED.position_bits,
    term_frequency = EXCLUDED.term_frequency
RETURNING word, url_id, position_bits, term_frequency
`

type UpsertWordDataParams struct {
	Word          string
	UrlID         int64
	PositionBits  []byte
	TermFrequency int32
}

func (q *Queries) UpsertWordData(ctx context.Context, arg UpsertWordDataParams) (WordDatum, error) {
	row := q.db.QueryRow(ctx, upsertWordData,
		arg.Word,
		arg.UrlID,
		arg.PositionBits,
		arg.TermFrequency,
	)
	var i WordDatum
	err := row.Scan(
		&i.Word,
		&i.UrlID,
		&i.PositionBits,
		&i.TermFrequency,
	)
	return i, err
}
